import { hash, verify } from 'argon2';

export const argon2Adapter = {
  async createHashFromPassword(password): Promise<string> {
    /*Argon2 доступен в двух вариантах: Argon2i и Argon2d. Первый делает больше проходов по памяти и более медленный,
      второй быстрее, но у него отсутствует защита от timing атак, а так же его сложнее подбирать на GPU.
      Если не уверены — выбирайте Argon2i.*/
    const passwordHash = await hash(password, {
      timeCost: 10, //3;
      /*Затраты времени — это количество проходов (итераций), используемых хеш-функцией. 
      Это увеличивает мощность хеширования за счет времени, необходимого для вычислений.*/
      /*type: argon2id; argon2i это '1'
      argon2d быстрее и обладает высокой устойчивостью к брутфорс-атакам на GPU , что полезно для криптовалют.
          argon2i медленнее и устойчив для атак по сторонним каналам (например, аппаратные кошельки, системы безопасности), 
          что предпочтительнее для хеширования паролей и получения ключей.
          argon2id представляет собой гибридную комбинацию вышеперечисленного, устойчивую к атакам с использованием GPU  и для атак по сторонним каналам.
        По умолчанию используется argon2id*/
      // associatedData:'userId';  как payload в JWT
      /* hashLength: 32; Длина хеша — это длина вывода хэш-функции в байтах. 
        Обратите внимание, что полученный хэш закодирован в Base 64, поэтому дайджест будет примерно на 1/3 длиннее.
        Значение по умолчанию — 32, что дает необработанные хэши длиной 32 байта или дайджесты длиной 43 символа.*/
      // memoryCost: 65536, //количество памяти в кибибайтах (киби = 1024) по умолчанию 63МБ
      /* parallelism: 4; Количество потоков для вычисления хеша. Каждый поток имеет пул памяти размером MemoryCost.
        Обратите внимание, что его изменение также меняет полученный хэш.*/
      /* secret: Buffer.from('123'); Также известный как «перец» в хешировании паролей, это дополнительные данные,
        используемые в процессе хеширования, которые не включаются в хеш, как соль. 
        Он должен быть достаточно случайным и непредсказуемым и надежно храниться, чтобы предотвратить компрометацию. 
        Секрет должен быть экземпляром Buffer*/

      /*Приведенные ниже параметры зарезервированы для весьма специфического использования. 
          Никогда не следует использовать их для хеширования паролей: отклонение от значений по умолчанию снизит вашу безопасность!*/

      // raw: false; сырой хеш в base64 кодировке. Eсли true, то можно не использовать метод verify для проверки пароля
      /*version: 1.3; Используемая версия Argon2. На данный момент доступны версии 1.0 (0x10) и 1.3 (0x13). 
        Вам не следует это менять, поскольку последняя версия более надежна*/
      /* salt: Buffer.from(hashRounds.toString()),  Соль для защиты данных от "радужных" таблиц. Не следует устанавливать собственную соль.
        Значение по умолчанию не установлено, что генерирует криптографически безопасную случайную соль*/
    });

    return passwordHash;
  },

  async validateHash(passwordHash, password): Promise<boolean> {
    const isMatch = await verify(passwordHash, password);
    return isMatch;
  },
};
